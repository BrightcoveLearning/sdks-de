---
title: 'Code-Snippets mit dem nativen SDK für iOS'
description: In diesem Thema finden Sie eine Sammlung von Codeausschnitten, die Sie bei der Entwicklung mit dem SDK als Referenz verwenden können. Detailliertere Lösungen finden Sie im <a href="https://github.com/BrightcoveOS/ios-player-samples">iOS-Player-Beispiele</a> .
parent: Resources 
grandparent: iOS Development
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <!-- The next tab set will be 41 and 42 -->

<section class="bcls-section" id="top">
<h3>Inhaltsverzeichnis</h3>
<!-- <h5 class="bcls-question">Accessibility</h5>

<ul class="bcls-answer">
	<li><a href="#VoiceOver_support">VoiceOver support</a></li>
</ul> -->
<details style="padding:0;">
    <summary>Werbung</summary>
   <ul>
      <li><a href="#Media_progress_values">Medienfortschrittswerte</a></li>
    </ul>
</details> 
<br/>

<details style="padding:0;">
    <summary>Analytik</summary>
    <ul>
      <li>Google Analytics<a href="#Google_Analytics"></a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>Bildunterschriften</summary>
    <ul>
      <li><a href="#Customizing_the_closed_captions_button">Anpassen der Schaltfläche für geschlossene Untertitel</a></li>
      <li><a href="#Modifying_captions_programmatically">Untertitel programmatisch ändern</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>Inhaltssicherheit (DRM)</summary>
   <ul>
      <li><a href="#Displaying_FairPlay_content_on_an_external_screen">Anzeige von FairPlay-Inhalten auf einem externen Bildschirm</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>Cue-Punkte</summary>
    <ul>
      <li><a href="#Programmatically_adding_cue_points">Programmgesteuertes Hinzufügen von Cue-Punkten</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>Wiedergabe</summary>
    <ul>
      <li><a href="#Custom_controls_for_AirPlay">Benutzerdefinierte Steuerelemente für AirPlay</a></li>
      <li><a href="#Limiting_the_bitrate">Begrenzung der Bitrate</a></li>
      <li><a href="#Looping_a_video">Ein Video loopen</a></li>
      <li><a href="#Media_progress_values">Medienfortschrittswerte</a></li>
      <!-- <li><a href="#Setting_the_buffer_size">Setting the buffer size</a></li> -->
      <li><a href="#Paging_with_the_Playback_API">Paging mit der Playback API</a></li>
      <li><a href="#Removing_the_player">Entfernen des Players</a></li>
      <li><a href="#Setting_audio_behavior">Audioverhalten einstellen</a></li>
      <li><a href="#Setting_the_playback_rate">Einstellen der Wiedergaberate</a></li>
      <li><a href="#Setting_VR_Goggles_mode_for_360_videos">Einstellen des VR-Brillenmodus für 360°-Videos</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>Wiedergabelisten</summary>
   <ul>
      <li><a href="#Managing_videos_in_a_playlist">Verwalten von Videos in einer Playlist</a></li>
    </ul>
</details>
<br/>

<details style="padding:0;">
    <summary>Styling</summary>
    <ul>
      <li><a href="#Changing_the_background_color">Ändern der Hintergrundfarbe</a></li>
    </ul>
</details>
<br/>
</section>

<section class="bcls-section">
<h2 id="Custom_controls_for_AirPlay">Benutzerdefinierte Steuerelemente für AirPlay</h2>

<p>Wenn Sie das verwenden <a href="/ios/reference/sdk/index.html#PlayerUI">Brightcove PlayerUI-Steuerelemente</a> , du bist fertig. Die AirPlay-Funktionalität ist sofort einsatzbereit und ermöglicht es Benutzern, Videos mit Apple TV auf High-Definition-Displays zu streamen.</p>

<p>Wenn Sie benutzerdefinierte Steuerelemente verwenden, können Sie die folgenden Schritte ausführen:</p>

<ol class="bcls-tasklist-restart">
	<li>
	<p>Erfahren Sie mehr über AirPlay in <a href="">Entwicklerdokumentation von Apple für AirPlay</a>.</p>
	</li>
	<li>
	<p>Verwenden Sie die <code translate="No">allowsExternalPlayback </code> -Eigenschaft, um die des AVPlayers einzustellen <code translate="No">allowsExternalPlayback </code> Eigentum:</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab1"></a></li>
      <li><a href="#tab2">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab1" class="tab active">
        <pre>
    <code class="language-objectivec" translate="No">_playbackController.allowsExternalPlayback = YES;</code></pre>
      </div>
      <div id="tab2" class="tab">
        <pre>
    <code class="language-swift" translate="No">playbackController.allowsExternalPlayback = true</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

	</li>
	<li>
	<p>Richten Sie eine AirPlay-Router-Steuerung ein und handhaben Sie ihre Auswahl. Einzelheiten finden Sie unter <a href="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AirPlayGuide/Introduction/Introduction.html">Apples AirPlay-Übersicht</a> dokumentieren.</p>
	</li>
</ol>
<h4>Referenz</h4>
  <p>Einzelheiten finden Sie im <a href="/ios/reference/sdk/Protocols/BCOVPlaybackController.html#//api/name/allowsExternalPlayback">BCOVPlaybackController</a> Dokumentation.</p>
</section>

<section class="bcls-section">
<h2 id="Customizing_the_closed_captions_button">Anpassen der Schaltfläche für geschlossene Untertitel</h2>

<p>Die <a href="/ios/reference/sdk/index.html#PlayerUI">BCOVPlayerUI-Beispielcode</a> zeigt Ihnen, wie Sie den Brightcove-Player anpassen, wenn Sie das Native SDK für iOS verwenden. Weitere Informationen finden Sie im <a href="/ios/reference/sdk/index.html#PlayerUI">Anpassen der PlayerUI-Steuerelemente</a> Abschnitt des Native SDK-Referenzdokuments.</p>

<p>Gehen Sie folgendermaßen vor, um die Untertitel-Schaltfläche mithilfe der PlayerUI anzupassen:</p>

<ol class="bcls-tasklist-restart">
	<li>
	<p>Beginnen Sie mit dem <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Player/VideoCloudBasicPlayer">Einfache Videowiedergabe-App</a>.</p>
	</li>
	<li>
	<p>Ersetzen Sie Ihre Werte für Richtlinienschlüssel, Konto-ID und Video-ID. Wählen Sie in Ihrem Konto ein Video mit Textspuren aus.</p>
	</li>
	<li>
	<p>Richten Sie die Player-Ansicht mit einem Standard-VOD-Layout ein:</p>
  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab3"></a></li>
      <li><a href="#tab4">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab3" class="tab active">
       <pre class="line-numbers">
<code class="language-objectivec" translate="No">// Set up our player view. Create with a standard VOD layout.
BCOVPUIPlayerView *playerView = [[BCOVPUIPlayerView alloc] 
initWithPlaybackController:self.playbackController options:nil controlsView:
[BCOVPUIBasicControlView basicControlViewWithVODLayout] ];</code></pre>
      </div>
      <div id="tab4" class="tab">
        <pre>
<code class="language-swift" translate="No">// Set up our player view. Create with a standard VOD layout.
guard let playerView = BCOVPUIPlayerView(playbackController: 
self.playbackController, options: options, controlsView: 
BCOVPUIBasicControlView.withVODLayout()) else {    
  return
}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

	
	</li>
	<li>
	<p>Die <code translate="No">closedCaptionButton</code> wird als a . deklariert <code translate="No">BCOVPUIButton</code> , die eine Unterklasse von ist <code translate="No">UIButton</code> und fügt drei zusätzliche Methoden zur Anpassung hinzu. Wann immer Sie BCOVPlayerUI-Steuerelemente anpassen, sollten Sie die nativen Player-APIs verwenden, wo immer sie verfügbar sind. Ihr benutzerdefinierter Code sollte ungefähr so aussehen:</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab5"></a></li>
      <li><a href="#tab6">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab5" class="tab active">
       <pre class="line-numbers">
<code class="language-objectivec" translate="No">// Customize the CC button.
BCOVPUIButton *ccButton = playerView.controlsView.closedCaptionButton;
ccButton.titleLabel.font = [UIFont systemFontOfSize:14.];
ccButton.primaryTitle = @&quot;CC&quot;;
[ccButton showPrimaryTitle:YES];</code></pre>
      </div>
      <div id="tab6" class="tab">
        <pre>
<code class="language-swift" translate="No">if let ccButton = playerView.controlsView.closedCaptionButton {    
  ccButton.titleLabel?.font = UIFont.systemFont(ofSize: 14)    
  ccButton.primaryTitle = &quot;CC&quot;    
  ccButton.showPrimaryTitle(true)}
}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

	</li>
</ol>
</section>

<section class="bcls-section">
<h2 id="Displaying_FairPlay_content_on_an_external_screen">Anzeige von FairPlay-Inhalten auf einem externen Bildschirm</h2>

<p>Wenn ein externes Display über einen AV-Adapter und ein HDMI-Kabel an ein iOS-Gerät angeschlossen ist, wird standardmäßig der iOS-Bildschirm gespiegelt. Ausgenommen hiervon ist die Verwendung von FairPlay-geschützten Videos, deren Spiegelung von Apple verhindert wird (<a href="https://developer.apple.com/videos/play/wwdc2015/502/">WWDC 2015, Sitzung 502</a>).</p>

<p>Um FairPlay-geschützte Videos anzuzeigen, legen Sie die AVPlayer-Eigenschaften fest, die über den Brightcove-Wiedergabe-Controller angezeigt werden, damit FairPlay-Videos auf einem externen Display wiedergegeben werden können. Das Video wird im Vollbildmodus abgespielt. Hier ist ein Beispiel für das Festlegen dieser Eigenschaften:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab7"></a></li>
      <li><a href="#tab8">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab7" class="tab active">
       <pre class="line-numbers">
<code class="language-objectivec" translate="No">playbackController.allowsExternalPlayback = YES;
playbackController.usesExternalPlaybackWhileExternalScreenIsActive = YES;</code></pre>
      </div>
      <div id="tab8" class="tab">
        <pre>
<code class="language-swift" translate="No">playbackController.allowsExternalPlayback = true
playbackController.usesExternalPlaybackWhileExternalScreenIsActive = true</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

  <h4>Referenz</h4>
  <p>Einzelheiten finden Sie im <a href="/ios/reference/sdk/Protocols/BCOVPlaybackController.html#//api/name/usesExternalPlaybackWhileExternalScreenIsActive">BCOVPlaybackController</a> Dokumentation.</p>


</section>

<section class="bcls-section">
<h2 id="Google_Analytics">Google Analytics</h2>

<p>Wenn Sie den Brightcove-Player und die Katalogklasse verwenden, werden Videoanalysen automatisch erfasst und in Ihrem Video Cloud-Analysemodul angezeigt. Für zusätzliche Messwerte können Sie Ihrer App Google Analytics hinzufügen.</p>

<p>Gehen Sie wie folgt vor, um Google Analytics in Ihre App zu integrieren:</p>

<ol class="bcls-tasklist-restart">
	<li>Überprüfen Sie das Dokument von Google, um <a href="https://developers.google.com/analytics/devguides/collection/ios/v3/#get-config">Fügen Sie Ihrer iOS-App Analytics hinzu</a>.</li>
	<li>
	<p>Hier ist eine Möglichkeit, wie Sie Google Analytics verwenden können, um die Videowiedergabe mit dem Firebase SDK von Google zu verfolgen:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab9"></a></li>
      <li><a href="#tab10">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab9" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// This snippet shows one way to track video playback
// using the Firebase SDK from Google Analytics with
// the lifecycle event playback controller delegate method.
- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
{
	// Common parameters
	NSString *video_name = session.video.properties[kBCOVVideoPropertyKeyName];
	NSString *video_ID = session.video.properties[kBCOVVideoPropertyKeyId];

	// Session is ready to play
	if ([kBCOVPlaybackSessionLifecycleEventReady isEqualToString:lifecycleEvent.eventType])
	{
		[FIRAnalytics logEventWithName:@&quot;bcov_video_ready&quot;
	    parameters:@{
	        @&quot;bcov_video_name&quot;: video_name,
	        @&quot;bcov_video_id&quot;: video_ID
	    }];
	}

	// Session encountered an error
	if ([kBCOVPlaybackSessionLifecycleEventError isEqualToString:lifecycleEvent.eventType])
	{
		NSError *error = lifecycleEvent.properties[kBCOVPlaybackSessionEventKeyError];
		int error_code = error.code;
		[FIRAnalytics logEventWithName:@&quot;bcov_video_playback_error&quot;
	    parameters:@{
	        @&quot;bcov_video_name&quot;: video_name,
	        @&quot;bcov_video_id&quot;: video_ID,
	        @&quot;bcov_video_error_code&quot;: @(error_code)
	    }];
	}

	// Session has completed
	if ([kBCOVPlaybackSessionLifecycleEventTerminate isEqualToString:lifecycleEvent.eventType])
	{
		[FIRAnalytics logEventWithName:@&quot;bcov_video_terminate&quot;
	    parameters:@{
	        @&quot;bcov_video_name&quot;: video_name,
	        @&quot;bcov_video_id&quot;: video_ID
	     }];
	}
}</code></pre>
      </div>
      <div id="tab10" class="tab">
        <pre>
<code class="language-swift" translate="No">// This snippet shows one way to track video playback
// using the Firebase SDK from Google Analytics with
// the lifecycle event playback controller delegate method.
func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent!) {
        
    // Common parameters
    let video_name = session.video.properties[kBCOVVideoPropertyKeyName]
    let video_id = session.video.properties[kBCOVVideoPropertyKeyId]
    
    // Session is ready to play
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventReady) {
        
        if let video_name = video_name as? String, let video_id = video_id as? String {
            Analytics.logEvent(&quot;bcov_video_ready&quot;, parameters: [
                &quot;bcov_video_name&quot; : video_name,
                &quot;bcov_video_id&quot; : video_id
            ])
        }
        
    }
    
    // Session encountered an error
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventError) {
     
        if let error = lifecycleEvent.properties[kBCOVPlaybackSessionEventKeyError] as? NSError {
            let error_code = error.code
            
            if let video_name = video_name as? String, let video_id = video_id as? String {
                Analytics.logEvent(&quot;bcov_video_playback_error&quot;, parameters: [
                    &quot;bcov_video_name&quot; : video_name,
                    &quot;bcov_video_id&quot; : video_id,
                    &quot;bcov_video_error_code&quot; : error_code
                ])
            }
        }
        
    }
    
    // Session has completed
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventTerminate) {
        
        if let video_name = video_name as? String, let video_id = video_id as? String {
            Analytics.logEvent(&quot;bcov_video_terminate&quot;, parameters: [
                &quot;bcov_video_name&quot; : video_name,
                &quot;bcov_video_id&quot; : video_id
            ])
        }
        
    }

}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->
	</li>
</ol>

<p>&nbsp;</p>
</section>

<section class="bcls-section">
<h2 id="Limiting_the_bitrate">Begrenzung der Bitrate</h2>

<p>Sie können nicht steuern, welche Quelle (Wiedergabe) im HLS-Manifest vom ausgewählt wird <code translate="No">AVPlayer </code> , aber Sie können eine Bitratenbegrenzung für die Wiedergabe festlegen. Dadurch wird verhindert, dass der Player Quellen (Wiedergaben) mit einer Bitrate über der angegebenen Bitrate verwendet.</p>

<p>Stellen Sie die <code translate="No">preferredPeakBitRate </code> bis zum gewünschten Grenzwert in Bits pro Sekunde des Netzwerkbandbreitenverbrauchs für den gegebenen <code translate="No">AVPlayerItem </code>.</p>

<p>Verwenden Sie eine der folgenden Deklarationen:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab11"></a></li>
      <li><a href="#tab12">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab11" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">[self.playbackController setPreferredPeakBitRate:1000];</code></pre>
      </div>
      <div id="tab12" class="tab">
        <pre>
<code class="language-swift" translate="No">playbackController.setPreferredPeakBitRate(1000)</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

</section>

<section class="bcls-section">
<h2 id="Looping_a_video">Ein Video loopen</h2>

<p>In einigen Fällen möchten Sie möglicherweise, dass ein Video automatisch wiedergegeben wird. Dazu können Sie das Lebenszyklusereignis "Ende des Videos" abrufen, zum Anfang suchen und erneut abspielen.</p>

<p>Dieser Code geht davon aus, dass Sie den Delegat des PlaybackControllers mit dieser Methode auf das Objekt gesetzt haben:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab13"></a></li>
      <li><a href="#tab14">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab13" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
{
	if ([kBCOVPlaybackSessionLifecycleEventEnd isEqualToString:lifecycleEvent.eventType])
	{
		[controller seekToTime:kCMTimeZero completionHandler:^(BOOL finished) {
			if (finished)
			{
				[controller play];
			}
		}];
	}
}</code></pre>
      </div>
      <div id="tab14" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent!) {
        
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventEnd) {
        controller.seek(to: CMTime.zero) { (finished: Bool) in
            if (finished) {
                controller.play()
            }
        }
    }
    
}</code></pre>
      </div>
    </div>
  </div>
  <!-- end tabs -->

</section>

<section class="bcls-section">
<h2 id="Managing_videos_in_a_playlist">Verwalten von Videos in einer Playlist</h2>

<p>Eine Möglichkeit, eine Wiedergabeliste mit Videos zu verwalten, besteht darin, die Videoobjekte in einer Tabelle zu speichern. Wenn der Benutzer ein Video aus der Tabelle auswählt, enthält die Tabellenzeile das Videoobjekt.</p>

<p>Hier ist eine Übersicht, wie es funktioniert:</p>

<ol class="bcls-tasklist-restart">
	<li>
	<p>Rufen Sie eine Playlist von Ihrem Konto ab.</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab15"></a></li>
      <li><a href="#tab16">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab15" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)retrievePlaylist
{
	[self.refreshControl beginRefreshing];

	// Retrieve a playlist through the BCOVPlaybackService
	BCOVPlaybackServiceRequestFactory *playbackServiceRequestFactory = [[BCOVPlaybackServiceRequestFactory alloc]         
  initWithAccountId:kDynamicDeliveryAccountID
	policyKey:kDynamicDeliveryPolicyKey];
	BCOVPlaybackService *playbackService = [[BCOVPlaybackService alloc] initWithRequestFactory:playbackServiceRequestFactory];

	[playbackService findPlaylistWithReferenceID:kDynamicDeliveryPlaylistRefID parameters:nil 
  completion:^(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error) 
	{
		[self.refreshControl endRefreshing];

		NSLog(@&quot;JSON Response:\n%@&quot;, jsonResponse);

		if (playlist)
		{
			self.currentVideos = playlist.videos.mutableCopy;
			self.currentPlaylistTitle = playlist.properties[@&quot;name&quot;];
			self.currentPlaylistDescription = playlist.properties[@&quot;description&quot;];

			NSLog(@&quot;Retrieved playlist containing %d videos&quot;, (int)self.currentVideos.count);

			[self usePlaylist:self.currentVideos];
		}
		else
		{
			NSLog(@&quot;No playlist for ID %@ was found.&quot;, kDynamicDeliveryPlaylistRefID);
		}

	}];
}</code></pre>
      </div>
      <div id="tab16" class="tab">
        <pre>
<code class="language-swift" translate="No">func retrievePlaylist() {
    refreshControl.beginRefreshing()
    
    let playbackServiceRequestFactory = BCOVPlaybackServiceRequestFactory(accountId: kDynamicDeliveryAccountID, policyKey: kDynamicDeliveryPolicyKey)
    let playbackService = BCOVPlaybackService(requestFactory: playbackServiceRequestFactory)
    
    playbackService?.findPlaylist(withPlaylistID: kDynamicDeliveryPlaylistRefID, parameters: nil, completion: { [weak self] (playlist: BCOVPlaylist?, jsonResponse: [AnyHashable:Any]?, error: Error?) in
        
        guard let strongSelf = self else {
            return
        }
        
        strongSelf.refreshControl.endRefreshing()
        
        if let playlist = playlist {
            strongSelf.currentVideos = playlist.videos
            strongSelf.currentPlaylistTitle = playlist.properties[&quot;name&quot;] as? String ?? &quot;&quot;
            strongSelf.currentPlaylistDescription = playlist.properties[&quot;description&quot;] as? String ?? &quot;&quot;
            
            print(&quot;Retrieved playlist containing \(playlist.videos.count) videos&quot;)
            
            strongSelf.usePlaylist(playlist)
        } else {
            print(&quot;No playlist for ID \(kDynamicDeliveryPlaylistRefID) was found.&quot;);
        }
        
    })
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

	</li>
	<li>
	<p>Initialisieren Sie die Container, die Informationen zu den Videos in der aktuellen Playlist speichern, neu.</p>
	</li>
	<li>
	<p>Wenn die Tabellenansicht ausgewählt ist, wird der Index der Zeile verwendet, um eine neue <code translate="No">videoDictionary</code>. Als nächstes fragen Sie das Wörterbuch nach dem Video. Wenn das Video nicht null ist, laden Sie das Video in die <code translate="No">playbackController</code>.</p>

  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab17"></a></li>
      <li><a href="#tab18">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab17" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// Play the video in this row when selected
- (IBAction)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(nonnull NSIndexPath *)indexPath
{
	NSDictionary *videoDictionary = self.videosTableViewData[ (int)indexPath.row ];
	BCOVVideo *video = videoDictionary[@&quot;video&quot;];

	if (video != nil)
	{
		[self.playbackController setVideos:@[ video ]];
	}
}</code></pre>
      </div>
      <div id="tab18" class="tab">
        <pre>
<code class="language-swift" translate="No">func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
    guard let videosTableViewData = videosTableViewData, 
    let videoDictionary = videosTableViewData[indexPath.row] as? 
    [AnyHashable:Any], let video = videoDictionary[&quot;video&quot;] as? BCOVVideo else {
        return
    }
    
    playbackController.setVideos([video] as NSFastEnumeration)
    
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

	</li>
</ol>

<p>Um mit Playlists zu arbeiten, können Sie die Playlist in einem anderen Objekt wie einer Tabelle speichern. Basierend auf der Benutzerinteraktion können Sie durch die Indizes des Objekts navigieren und das entsprechende Video auswählen.</p>

<aside class="bcls-aside bcls-aside--tip">Ein vollständiges Codebeispiel finden Sie im <a href="https://github.com/BrightcoveOS/ios-player-samples/tree/master/Offline">Offline-Player</a> Stichprobe.</aside>
</section>

<section class="bcls-section">
<h2 id="Media_progress_values">Medienfortschrittswerte</h2>

<p>Während der Medienwiedergabe können die der Player SDK-Fortschrittsdelegatenmethode gemeldeten Werte einen Anfangswert von negativ unendlich und einen Endwert von positiv unendlich umfassen. Diese Werte werden bei der Verarbeitung von Pre-Roll- und Post-Roll-Anzeigen verwendet.</p>

<p>Wenn diese Werte für Sie nicht wichtig sind oder Ihre eigene Fortschrittsverfolgung stören, können sie mit einer bedingten Anweisung wie dieser einfach ignoriert werden:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab19"></a></li>
      <li><a href="#tab20">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab19" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didProgressTo:(NSTimeInterval)progress
{
	if (progress &lt; 0.0 || progress &gt;= INFINITY)
	{
		return;
	}

	// Your code here
}</code></pre>
      </div>
      <div id="tab20" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didProgressTo progress: TimeInterval) {
        
    if (progress &lt; 0.0 || progress &gt;= Double.infinity) {
        return;
    }
    
    // Your code here
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<h4>Referenz</h4>
  <p>Einzelheiten finden Sie im <a href="/ios/reference/sdk/Protocols/BCOVPlaybackControllerBasicDelegate.html#//api/name/playbackController:playbackSession:didProgressTo:">BCOVPlaybackController</a> Dokumentation.</p>

</section>

<section class="bcls-section">
  <h2 id="Modifying_captions_programmatically">Untertitel programmatisch ändern</h2>
  <p>Sie können die Untertitel jederzeit während der Wiedergabe einstellen, nach dem <code translate="No">Ready</code> Veranstaltung eingegangen ist. Dazu können Sie die <a href="/ios/reference/sdk/Protocols/BCOVPlaybackControllerDelegate.html">BCOVPlaybackControllerDelegate</a>.</p>
  
  <p>Hier ist ein Beispiel für die Einstellung der Untertitelsprache auf Spanisch:</p>
  
    <!-- tabs -->
    <div class="tabs">
      <ul class="tab-links">
        <li class="active">Obj-C<a href="#tab35"></a></li>
        <li><a href="#tab36">Schnell</a></li>
      </ul>
  
      <div class="tab-content">
        <div id="tab35" class="tab active">
         <pre class="line-numbers">
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
  {
      if ([kBCOVPlaybackSessionLifecycleEventReady isEqualToString:lifecycleEvent.eventType])
      {
          AVMediaSelectionGroup *legibleMediaSelectionGroup = session.legibleMediaSelectionGroup;
          NSArray&lt;AVMediaSelectionOption *&gt; *options = [AVMediaSelectionGroup mediaSelectionOptionsFromArray:legibleMediaSelectionGroup.options withLocale:[NSLocale localeWithLocaleIdentifier:@&quot;es&quot;]];
          AVMediaSelectionOption *option = options.firstObject;
          session.selectedLegibleMediaOption = option;
      }
  }</code></pre>
        </div>
        <div id="tab36" class="tab">
          <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController?, playbackSession session: BCOVPlaybackSession?, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent?) {
    if kBCOVPlaybackSessionLifecycleEventReady == lifecycleEvent?.eventType {
        if let legibleMediaSelectionGroup = session?.legibleMediaSelectionGroup.options {
            let locale = NSLocale(localeIdentifier: &quot;es&quot;) as Locale
            let mediaSelectionOptions = AVMediaSelectionGroup.mediaSelectionOptions(from: legibleMediaSelectionGroup, with: locale)
            let mediaSelectionOption = mediaSelectionOptions.first
            session?.selectedLegibleMediaOption = mediaSelectionOption
        }
    }
}</code></pre>
        </div>
      </div>
    </div>
    <!-- end tabs -->
  </section>

<section class="bcls-section">
<h2 id="Paging_with_the_Playback_API">Paging mit der Playback API</h2>

<p>Beim Abrufen Ihres Video Cloud-Inhalts von der Wiedergabe-API können Sie das Paging für eine Wiedergabeliste implementieren.</p>

<p>Um durch eine Reihe von Videos in einer Playlist zu blättern, verwenden Sie die folgenden Anforderungs-URL-Parameter:</p>

<ul>
	<li><code translate="No"><a href="https://apis.support.brightcove.com/playback/getting-started/overview-playback-api.html#playlistRequests">limit</a> </code>- definiert die Anzahl der Videos, die von der Playback API zurückgegeben werden sollen</li>
	<li><code translate="No"><a href="https://apis.support.brightcove.com/playback/getting-started/overview-playback-api.html#playlistRequests">offset</a> </code>- legt die Anzahl der zu überspringenden Videos in einer Playlist über die Playback API fest</li>
</ul>

<p>In diesem Beispiel werden 6 Videos zurückgegeben, beginnend mit dem 10. Video in der Playlist:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab21"></a></li>
      <li><a href="#tab22">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab21" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">NSDictionary *params = @{
	@&quot;limit&quot;: @6,
	@&quot;offset&quot;: @9
};

[playbackService findPlaylistWithReferenceID:playlistRefID parameters:params completion:^(BCOVPlaylist *playlist, NSDictionary *jsonResponse, NSError *error)
{ 
    // Your code here
}];</code></pre>
      </div>
      <div id="tab22" class="tab">
        <pre>
<code class="language-swift" translate="No">let params = [
    &quot;limit&quot;: 6,
    &quot;offset&quot;: 9
]

playbackService?.findPlaylist(withPlaylistID: playlistRefID, parameters: params, completion: { (playlist: BCOVPlaylist?, jsonResponse: [AnyHashable:Any]?, error: Error?) in
    // Your code here
})</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

</section>

<section class="bcls-section">
<h2 id="Programmatically_adding_cue_points">Programmgesteuertes Hinzufügen von Cue-Punkten</h2>

<p>Kunden von Video Cloud können einem Video mithilfe von Video Cloud Studio Cue-Punkte hinzufügen, wie in der <a href="https://studio.support.brightcove.com/media/working-cue-points-media-module.html">Hinzufügen von Cue-Punkten zu Videos</a> dokumentieren.</p>

<p>Sie können Ihrem Video auch programmgesteuert Cue-Points hinzufügen. Der folgende Code fügt dem von der Playback API zurückgegebenen Video vierteljährliche Cue-Points hinzu:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab23"></a></li>
      <li><a href="#tab24">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab23" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// programmatically add cue points to a video
- (void)requestContentFromPlaybackService
{
    [self.service findVideoWithVideoID:kViewControllerVideoID parameters:nil completion:^(BCOVVideo *video, NSDictionary *jsonResponse, NSError *error) {
        if (video)
        {
            // Get the video duration from the properties dictionary
            NSNumber *durationNumber = video.properties[@&quot;duration&quot;]; // milliseconds
            float duration = durationNumber.floatValue / 1000.0; // convert to seconds
            video = [video update:^(id&lt;BCOVMutableVideo&gt; mutableVideo)
            {
                // Add quarterly interval cue points of your own type
                BCOVCuePoint *cp1 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 250, 1000)];
                BCOVCuePoint *cp2 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 500, 1000)];
                BCOVCuePoint *cp3 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 750, 1000)];
                BCOVCuePoint *cp4 = [[BCOVCuePoint alloc] initWithType:@&quot;<span class="bcls-input">your cue point type</span>&quot; position:CMTimeMake(duration * 1000, 1000)];
                // Create new cue point collection using existing cue points and new cue points
                NSMutableArray *newCuePoints = [[NSMutableArray alloc] initWithArray:mutableVideo.cuePoints.array];
                [newCuePoints addObject:cp1];
                [newCuePoints addObject:cp2];
                [newCuePoints addObject:cp3];
                [newCuePoints addObject:cp4];
                mutableVideo.cuePoints = [[BCOVCuePointCollection alloc] initWithArray:newCuePoints];
            }];
                
            [self.playbackController setVideos:@[ video ]];
        }
        else
        {
            NSLog(@&quot;ViewController Debug - Error retrieving video: `%@`&quot;, error);
        }
    }];
}</code></pre>
      </div>
      <div id="tab24" class="tab">
        <pre>
<code class="language-swift" translate="No">// programmatically add cue points to a video
func requestContentFromPlaybackService() {
    playbackService?.findVideo(withVideoID: kViewControllerVideoID, parameters: nil) 
    { [weak self] (video: BCOVVideo?, jsonResponse: [AnyHashable: Any]?, error: Error?) -&gt; Void in

        if let error = error {
            print(&quot;ViewController Debug - Error retrieving video: `\(error.localizedDescription)`&quot;)
        }
        
        if let video = video {
            
            // Get the video duration from the properties dictionary
            guard let durationNumber = video.properties[&quot;duration&quot;] as? NSNumber else {
                return
            }
            
            let duration = durationNumber.floatValue / 1000.0; // convert to seconds
            
            let updatedVideo = video.update({ (mutableVideo: BCOVMutableVideo?) in
                
                guard let mutableVideo = mutableVideo else {
                    return
                }
                
                // Add quarterly interval cue points of your own type
                let cp1Position = CMTimeMake(value: Int64(duration * 250), timescale: 1000)
                let cp1 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp1Position)!
                let cp2Position = CMTimeMake(value: Int64(duration * 500), timescale: 1000)
                let cp2 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp2Position)!
                let cp3Position = CMTimeMake(value: Int64(duration * 750), timescale: 1000)
                let cp3 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp3Position)!
                let cp4Position = CMTimeMake(value: Int64(duration * 1000), timescale: 1000)
                let cp4 = BCOVCuePoint(type: &quot;<span class="bcls-input">your cue point type</span>&quot;, position: cp4Position)!
                
                // Create new cue point collection using existing cue points and new cue points
                var newCuePoints = [BCOVCuePoint]()
                newCuePoints.append(cp1)
                newCuePoints.append(cp2)
                newCuePoints.append(cp3)
                newCuePoints.append(cp4)
                
                mutableVideo.cuePoints = BCOVCuePointCollection(array: newCuePoints)
            })
            
            self?.playbackController.setVideos([updatedVideo] as NSFastEnumeration)
        }
        
    }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<p>Beachten Sie, dass der Wert von <code translate="No">your cue point type </code> kann ein beliebiger String-Wert sein, solange Sie keinen der <a href="/ios/basics/overview-brightcove-player-sdk-ios.html#Integrations">iOS-Plugins</a>. Einzelheiten finden Sie im <a href="/ios/reference/sdk/Protocols/BCOVCuePoint.html#//api/name/type">BCOVCuePoint-Protokollreferenz</a> dokumentieren.</p>

<p>Wenn Sie Cue-Points mit dem IMA-Plugin verwenden, erfahren Sie mehr darüber im <a href="https://github.com/brightcove/brightcove-player-sdk-ios-ima#vast-and-vmapserver-side-ad-rules">VAST- und VMAP-/serverseitige Anzeigenregeln</a> Abschnitt des IMA-Plug-ins für das Native SDK für iOS-Notizen. Die <a href="https://github.com/brightcove/brightcove-player-sdk-ios-ima/blob/06bb6f8dff6075340737017a966ad19b20bf6adb/ios/BrightcoveIMA.framework/Headers/BCOVIMAComponent.h#L39-L42">IMA-Beispiel-App</a> zeigt Ihnen den für IMA-Anzeigen-Cue-Points erforderlichen Wert an.</p>

<p>Der folgende Code lauscht auf Ihre Cue-Punkte und zeigt eine Meldung an:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab25"></a></li>
      <li><a href="#tab26">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab25" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">// listen for cue points and display them
-(void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didPassCuePoints:(NSDictionary *)cuePointInfo
{
    BCOVCuePointCollection *cpc = cuePointInfo[@&quot;kBCOVPlaybackSessionEventKeyCuePoints&quot;];
    for (BCOVCuePoint *cp in cpc.array)
    {
        if ([cp.type isEqualToString:@&quot;<span class="bcls-input">your cue point type</span>&quot;])
        {
            NSLog(@&quot;Found your cue point at %f&quot;, CMTimeGetSeconds(cp.position));
        }
    }
}</code></pre>
      </div>
      <div id="tab26" class="tab">
        <pre>
<code class="language-swift" translate="No">// listen for cue points and display them
func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didPassCuePoints cuePointInfo: [AnyHashable : Any]!) {
    if let cpc = cuePointInfo[kBCOVPlaybackSessionEventKeyCuePoints] as? BCOVCuePointCollection {
        for cp in cpc.array() {
            if let cp = cp as? BCOVCuePoint {
                if (cp.type == &quot;<span class="bcls-input">your cue point type</span>&quot;) {
                    print(&quot;Found your cue point at \(CMTimeGetSeconds(cp.position))&quot;)
                }
            }
        }
    }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<h4>Verweise</h4>
  <p>Einzelheiten finden Sie unter:</p>
  <ul>
    <li><a href="/ios/reference/sdk/Protocols/BCOVVideo.html">BCOVVideo</a> Dokumentation</li>
     <li><a href="/ios/reference/sdk/Protocols/BCOVCuePoint.html">BCOVCuePoint</a> Dokumentation</li>
  </ul>
</section>
<!-- <section class="bcls-section" id="Setting_the_buffer_size">
		<h2>Setting the buffer size</h2>
		<p>You may consider increasing the buffer length to eliminate buffering in the player if the delivery of the next segment is delayed from the CDN. But, you may not be able to do anything better manually that HLS already does.</p>
		<p>The <code translate="No">AVPlayer</code> contains the <code translate="No">AVPlayerItem</code>, essentially the video being played, that contains the <code translate="No">loadedTimeRanges</code> property. This tells you how much is buffered.</p>
		<p>HLS is designed to play right away and drop quality if it can't keep up. This way, it does not need to preload a buffer. If it can't keep up, it will load as much of the video as it can at the best quality to prevent interruption.</p>
		</section> -->

<section class="bcls-section">
<h2 id="Removing_the_player">Entfernen des Players</h2>

<p>Es kann Fälle geben, in denen Sie den Player und die Ansicht entfernen möchten.</p>
<p>
  Aufheben der Zuordnung des Ansichtscontrollers, der Eigentümer von a . ist <code translate="No">BCOVPlaybackController</code> wird auch den Playback-Controller freigeben. Entfernen Sie dazu die Player-Ansicht aus ihrer Übersicht und setzen Sie ihren Wiedergabe-Controller-Zeiger auf <code translate="No">nil</code>.
</p>
<p>
  Hier ist ein Codebeispiel:
</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab27"></a></li>
      <li><a href="#tab28">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab27" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">[self.playerView removeFromSuperview];
self.playerView = nil;
self.playbackController = nil;</code></pre>
      </div>
      <div id="tab28" class="tab">
        <pre>
<code class="language-swift" translate="No">playerView?.removeFromSuperview()
playerView = nil
playbackController = nil</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

</section>

<section class="bcls-section">
  <h2 id="Setting_audio_behavior">Audioverhalten einstellen</h2>
  
  <p>Die Audiositzung behandelt das Audioverhalten auf App-Ebene. Sie können aus mehreren Audiositzungskategorien und -einstellungen wählen, um das Audioverhalten Ihrer App anzupassen.</p>
  <p>Wählen Sie die beste Audiositzungskategorie für Ihre App. Weitere Informationen finden Sie in der Dokumentation von Apple:</p>
  <ul>
    <li><a href="https://developer.apple.com/documentation/avfaudio/avaudiosession">AVAudioSession-Klasse</a></li>
    <li><a href="https://developer.apple.com/documentation/avfaudio/avaudiosessioncategory">AVAudioSessionKategorie</a></li>
  </ul>
  <h3>Basisbeispiel</h3>
  <p>Für unser Basismuster verwenden wir <code translate="No">AVAudioSessionCategoryPlayback</code>. Dies spielt auch dann Audio ab, wenn der Bildschirm gesperrt ist und der Schalter Klingeln/Stumm auf lautlos eingestellt ist. Der Einfachheit halber haben wir den Code dafür im App Delegate hinterlegt.</p>
  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab37"></a></li>
      <li><a href="#tab38">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab37" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">NSError *categoryError = nil;
  BOOL success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;categoryError];
  if (!success)
  {
      // Handle error
  }</code></pre>
      </div>
      <div id="tab38" class="tab">
        <pre>
<code class="language-swift" translate="No">var categoryError :NSError?
  var success: Bool
  do {
      try AVAudioSession.sharedInstance().setCategory(.playback)
      success = true
  } catch let error as NSError {
      categoryError = error
      success = false
  }
  if !success {
      // Handle error
  }</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

  <h3>Mit anderem Audio mischen</h3>
  <p>Möglicherweise möchten Sie zulassen, dass Audio von anderen Apps gehört wird, wenn das Audio in Ihrer App stummgeschaltet ist. Dazu können Sie die <code translate="No">AVAudioSession</code> im Ansichtscontroller, der Zugriff auf Ihr aktuelles hat <code translate="No">AVPlayer</code>.</p>
  <p>Einzelheiten finden Sie im <a href="https://developer.apple.com/documentation/avfaudio/avaudiosession/categoryoptions/1616611-mixwithothers">mixWithOthers</a> Kategorie Option.</p>
  <!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab39"></a></li>
      <li><a href="#tab40">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab39" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)setUpAudioSession
  {
      NSError *categoryError = nil;
      BOOL success;
      
      // If the player is muted, then allow mixing.
      // Ensure other apps can have their background audio active when this app is in foreground
      if (self.currentPlayer.isMuted)
      {
          success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionMixWithOthers error:&amp;categoryError];
      }
      else
      {
          success = [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:0 error:&amp;categoryError];
      }
      
      if (!success)
      {
          NSLog(@&quot;AppDelegate Debug - Error setting AVAudioSession category.  Because of this, there may be no sound. `%@`&quot;, categoryError);
      }
  }</code></pre>
      </div>
      <div id="tab40" class="tab">
        <pre>
<code class="language-swift" translate="No">func setUpAudioSession() {
  var categoryError :NSError?
  var success: Bool
  do {
      if let currentPlayer = currentPlayer {
          // If the player is muted, then allow mixing.
          // Ensure other apps can have their background audio active when this app is in foreground
          if currentPlayer.isMuted {
              try AVAudioSession.sharedInstance().setCategory(.playback, options: .mixWithOthers)
          } else {
              try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0))
          }
      } else {
          try AVAudioSession.sharedInstance().setCategory(.playback, options: AVAudioSession.CategoryOptions(rawValue: 0))
      }
      
      success = true
  } catch let error as NSError {
      categoryError = error
      success = false
  }
  if !success {
      print(&quot;AppDelegate Debug - Error setting AVAudioSession category.  Because of this, there may be no sound. \(categoryError!)&quot;)
  }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->
  
  </section>

<section class="bcls-section">
<h2 id="Setting_the_playback_rate">Einstellen der Wiedergaberate</h2>

<p>Um die Wiedergaberate zu steuern, können Sie die <code translate="No">rate </code> Eigentum auf der <code translate="No">AVPlayer </code> Klasse in der Sitzung ausgesetzt.</p>

<p>Standardmäßig kann die Abspielrate nur in regelmäßigen Abständen (0,50, 0,67, 1,0, 1,25, 1,50 und 2,0) eingestellt werden. Durch Einstellen der <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm">audioTimePitchAlgorithmus</a> , können Sie detailliertere Ratenwerte verwenden (z. B. 1.7). Weitere Details finden Sie hier <a href="https://stackoverflow.com/questions/6630356/avplayer-rate-property-does-not-work">Stackoverflow-Diskussion</a>.</p>

<pre>
<code class="language-objectivec" translate="No">avPlayerItem.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithmVarispeed;</code></pre>

<aside class="bcls-aside bcls-aside--information">
  <p>
    Auch wenn dieses Beispiel die <code translate="No">varispeed</code> Eigenschaftstyp, der <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm">AVAudioTimePitchAlgorithmus</a> -Klasse hat 4 Eigenschaftstypen, die Sie verwenden können:
  </p>
  <ul>
    <li>
      lowQualityZeroLatency<a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1621212-lowqualityzerolatency"></a>
    </li>
    <li>
      <a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1388153-spectral">spektral</a>
    </li>
    <li>
      timeDomain<a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1387220-timedomain"></a>
    </li>
    <li>
      varispeed<a href="https://developer.apple.com/documentation/avfoundation/avaudiotimepitchalgorithm/1387887-varispeed"></a>
    </li>
  </ul>
  <p>
    Beachten Sie, dass die <code translate="No">varispeed</code> Option bietet keine Tonhöhenkorrektur. Dies kann dazu führen, dass Audio mit einer hohen Wiedergaberate wie 1,7 unnatürlich hoch ist. Wählen Sie die Immobilienoption, die Ihren Bedürfnissen am besten entspricht.
  </p>
</aside>

<p>Für ein <code translate="No">BCOVPlaybackSession </code> , würde Ihr Code so aussehen:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab29"></a></li>
      <li><a href="#tab30">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab29" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller
  playbackSession:(id&lt;BCOVPlaybackSession&gt;)session didReceiveLifecycleEvent:(BCOVPlaybackSessionLifecycleEvent *)lifecycleEvent
{
    if ( [lifecycleEvent.eventType isEqualToString:kBCOVPlaybackSessionLifecycleEventReady] )
    {
        NSLog(@&quot;%@ at time %f&quot;, kBCOVPlaybackSessionLifecycleEventReady, CMTimeGetSeconds([session.player currentTime]));
        AVPlayerItem *avPlayerItem = [session.player currentItem];
        avPlayerItem.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithmVarispeed;
        session.player.rate = 1.7;
    }
}</code></pre>
      </div>
      <div id="tab30" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, playbackSession session: BCOVPlaybackSession!, didReceive lifecycleEvent: BCOVPlaybackSessionLifecycleEvent!) {
    
    if (lifecycleEvent.eventType == kBCOVPlaybackSessionLifecycleEventReady) {
        let seconds = CMTimeGetSeconds(session.player.currentTime())
        print(&quot;kBCOVPlaybackSessionLifecycleEventReady at time \(seconds)&quot;)
        let avPlayerItem = session.player.currentItem
        avPlayerItem?.audioTimePitchAlgorithm = AVAudioTimePitchAlgorithm.varispeed
        session.player.rate = 1.7
    }
    
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<aside class="bcls-aside bcls-aside--information"> Das Native SDK für iOS unterstützt keine negativen Werte für die Wiedergaberate (d. h. wir unterstützen keine umgekehrte Wiedergabe von Videos).
<!-- <p>Notes</p>
<ul>
  <li>For iOS6, a stream can only play at 2X if <code translate="No">session.player.currentItem.canPlayFastForward </code> returns <strong>YES</strong>.</li>
	<li>For iOS7, you can play up to 2X always, but it won't go higher unless <code translate="No">session.player.currentItem.canPlayFastForward </code> returns <strong>Yes</strong>.</li>
	<li>For more information about managing playback, see Apple's <a href="https://developer.apple.com/library/ios/documentation/AVFoundation/Reference/AVPlayer_Class/index.html#//apple_ref/occ/instp/AVPlayer/rate">AVPlayer Class Reference</a>.</li>
</ul> -->
</aside>
</section>

<section class="bcls-section">
<h2 id="Setting_VR_Goggles_mode_for_360_videos">Einstellen des VR-Brillenmodus für 360°-Videos</h2>

<p>Beim Abspielen eines 360°-Videos können Benutzer die Schaltfläche Video 360 in der Steuerleiste auswählen, um in den VR-Brillenmodus zu wechseln. Sie können dies auch programmgesteuert tun, bevor die Wiedergabe beginnt. Sie können dies tun, indem Sie die <code translate="No">BCOVPlaybackController </code> Protokolle <code translate="No">viewProjection </code> Eigentum wie folgt:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab31"></a></li>
      <li><a href="#tab32">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab31" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller didAdvanceToPlaybackSession:(id&lt;BCOVPlaybackSession&gt;)session
{
    BCOVVideo360ViewProjection *viewProjection = [self.playbackController.viewProjection copy];
    [viewProjection setProjectionStyle:BCOVVideo360ProjectionStyleVRGoggles];
    [self.playbackController setViewProjection:viewProjection];
}</code></pre>
      </div>
      <div id="tab32" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, didAdvanceTo session: BCOVPlaybackSession!) {
    if let viewProjection: BCOVVideo360ViewProjection = controller.viewProjection.copy() as? BCOVVideo360ViewProjection {
        viewProjection.projectionStyle = BCOVVideo360ProjectionStyle.vrGoggles
        playbackController.viewProjection = viewProjection
    }
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<aside class="bcls-aside bcls-aside--information">Beachten Sie, dass Sie den Projektionsstil des Controllers im <code translate="No">didAdvanceToPlaybackSession </code> Delegate-Methode.</aside>
</section>
<!-- <section class="bcls-section">
<h2 id="VoiceOver_support">VoiceOver support</h2>

<p>Apple's <a href="https://www.apple.com/accessibility/iphone/vision/">VoiceOver app</a>, which is integrated in iOS, allows visually impaired users to hear a description of everything that is on the screen.</p>

<p>The built-in playback controls for Brightcove Native SDK for iOS come with accessibility labels which have no default text values. If you want to take advantage of VoiceOver, you can add your own custom text values. The UIControl objects can be found in the following:</p>

<ul>
	<li>All the normal playback controls are found in the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html#//api/name/controlsView">BCOVPUIBasicControlView *controlsView</a> property of the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a>.</li>
	<li>All of the ad controls are found in the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html#//api/name/adControlsView">BCOVPUIAdControlView *adControlsView</a> property of the <a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html">BCOVPUIPlayerView</a>.</li>
</ul>

<p>This example shows how to customize the accessibility values for the play button:</p>

<pre class="line-numbers">
<code class="language-objectivec" translate="No"><a href="/ios/reference/sdk/Classes/BCOVPUIPlayerView.html#//api/name/controlsView">// After creating the BCOVPUIPlayerView, store it in a playerView property
// Then set the accessibilityLabel and accessibilityHint properties
self.playerView.controlsView.playbackButton.accessibilityLabel = @"Playback Button";
self.playerView.controlsView.playbackButton.accessibilityHint = @"Play or pause the video";</a>
</code></pre>

<aside class="bcls-aside bcls-aside--information">If you are using your own playback controls, then you have to add VoiceOver support yourself.</aside>
</section> -->

<section class="bcls-section">
<h2 id="Changing_the_background_color">Ändern der Hintergrundfarbe</h2>

<p>Wenn Sie ein Video im Hochformat abspielen, bemerken Sie möglicherweise einen schwarzen Rand oberhalb und unterhalb des Players. Die Player-Ansicht hat die Größe des Bildschirms, aber das Video nimmt nur einen kleinen Teil der Mitte der Player-Ansicht ein. Die sichtbaren Teile um das Video herum sind der Hintergrund der Player-Ebene.</p>

<p>Das ist normal <code translate="No">AVPlayer </code> Verhalten. Es verkleinert Ihr Video, damit es in die Player-Ebene passt, und der Rest ist der Hintergrund der Player-Ebene.</p>

<p>Sie können den Hintergrund der Player-Ebene mit dem folgenden Code ändern:</p>

<!-- tabs -->
  <div class="tabs">
    <ul class="tab-links">
      <li class="active">Obj-C<a href="#tab33"></a></li>
      <li><a href="#tab34">Schnell</a></li>
    </ul>

    <div class="tab-content">
      <div id="tab33" class="tab active">
        <pre>
<code class="language-objectivec" translate="No">- (void)playbackController:(id&lt;BCOVPlaybackController&gt;)controller didAdvanceToPlaybackSession:(id&lt;BCOVPlaybackSession&gt;)session
{
    session.playerLayer.backgroundColor = UIColor.whiteColor.CGColor;
}</code></pre>
      </div>
      <div id="tab34" class="tab">
        <pre>
<code class="language-swift" translate="No">func playbackController(_ controller: BCOVPlaybackController!, didAdvanceTo session: BCOVPlaybackSession!) {
    session.playerLayer.backgroundColor = UIColor.white.cgColor
}</code></pre>
      </div>
    </div>
  </div>
<!-- end tabs -->

<p>&nbsp;</p>
<p>Die Einstellung der Hintergrundfarbe auf Weiß sollte so aussehen:</p>

<figure class="bcls-figure"><img class="bcls-image--no-border" alt="Background color" src="//learning-services-media.brightcove.com/doc-assets/device-sdks/ios/snippets/ios-bkgd-color.png" />
<figcaption class="bcls-caption--image">Benutzerdefinierte Hintergrundfarbe</figcaption>
</figure>
</section>
</article>